; Kulibrat but without vertical moves, board capture and piece limit

; CONFIGURATION
(score_limit 1)

; ROLES
(role redplayer)
(role blackplayer)

;*******************************************************************************
;* Initial state.                                                              *
;* Letters are columns: row 3 is RED side, row 1 is BLACK                      *
;*******************************************************************************

(init (cell 1 1 b))
(init (cell 1 2 b))
(init (cell 1 3 b))
(init (cell 2 1 b))
(init (cell 2 2 b))
(init (cell 2 3 b))
(init (cell 3 1 b))
(init (cell 3 2 b))
(init (cell 3 3 b))

(init (control redplayer))
(init (score redplayer 0))
(init (score blackplayer 0))

; End initial state

;*******************************************************************************
;* NEXT STATE AXIOMS: REGULAR MOVES                                            *
;*******************************************************************************

; MOVE SOURCE
; Piece ?p moves out of ?u ?v leaving square blank
(<= (next (cell ?u ?v b))
    (does ?player (move ?p ?u ?v ?x ?y)))

; MOVE DESTINATION
; Piece red moves to ?x ?y
(<= (next (cell ?x ?y ?p))
    (does ?player (move ?p ?u ?v ?x ?y)))

; REMOVE PIECE
(<= (next (cell ?u ?v b))
    (does ?player (remove ?p ?u ?v)))

; ADD PIECE
(<= (next (cell ?x ?y ?p))
    (does ?player (add ?p ?x ?y)))

; GAIN POINT
(<= (next (score ?player ?y))
    (does ?player (remove ?p ?u ?v))
    (true (score ?player ?x))
    (succ ?x ?y))

; SCORE STATIC
(<= (next (score ?player ?y))
    (does ?player (add ?piece ?x1 ?y1))
    (true (score ?player ?y)))

(<= (next (score ?player ?y))
    (does ?player (move ?piece ?x1 ?y1 ?x2 ?y2))
    (true (score ?player ?y)))

; UNDISTURBED CELLS
; Piece, or blank, ?p at ?x ?y remains unchanged if:
; ?x ?y is a different cell from the move source cell
; ?x ?y is a different cell from the move destination cell
(<= (next (cell ?x ?y ?p))
    (does ?player (move ?piece ?x1 ?y1 ?x2 ?y2))
    (true (cell ?x ?y ?p))
    (different_cells ?x ?y ?x1 ?y1)
    (different_cells ?x ?y ?x2 ?y2))

(<= (next (cell ?x ?y ?p))
    (does ?player (add ?piece ?x1 ?y1))
    (true (cell ?x ?y ?p))
    (different_cells ?x ?y ?x1 ?y1))

(<= (next (cell ?x ?y ?p))
    (does ?player (remove ?piece ?x1 ?y1))
    (true (cell ?x ?y ?p))
    (different_cells ?x ?y ?x1 ?y1))

; Noop when in control changes nothing
(<= (next (cell ?x ?y ?p))
    (does ?player noop)
    (true (control ?player))
    (true (cell ?x ?y ?p)))

; Score can only be changed when removing piece
(<= (next (score ?player ?y))
    (does ?player noop)
    (true (score ?player ?y)))

; CONTROL TRANSFER
(<= (next (control redplayer))
    (true (control blackplayer)))

(<= (next (control blackplayer))
    (true (control redplayer)))

;*******************************************************************************
;* LEGAL PIECE MOVES                                                           *
;*******************************************************************************

(<= (legal ?player (move ?piece ?u ?v ?x ?y))
    (role ?player)
    (true (control ?player))
    (legal_move ?player ?piece ?u ?v ?x ?y))

(<= (legal ?player (add ?piece ?u ?v))
    (role ?player)
    (true (control ?player))
    (legal_add ?player ?piece ?u ?v))

(<= (legal ?player (remove ?piece ?u ?v))
    (role ?player)
    (true (control ?player))
    (legal_remove ?player ?piece ?u ?v))

;; DIAGONAL MOVE. Requires destination to be blank
(<= (legal_move ?player ?piece ?u ?v ?x ?y)
    (piece_owner ?piece ?player)
    (true (cell ?u ?v ?piece))
    (true (cell ?x ?y b))
    (diagonal_move ?player ?u ?v ?x ?y))

(<= (diagonal_move redplayer ?u ?v ?x ?y)
    (clear_diagonal_nw ?u ?v ?x ?y))
(<= (diagonal_move redplayer ?u ?v ?x ?y)
    (clear_diagonal_ne ?u ?v ?x ?y))
(<= (diagonal_move blackplayer ?u ?v ?x ?y)
    (clear_diagonal_se ?u ?v ?x ?y))
(<= (diagonal_move blackplayer ?u ?v ?x ?y)
    (clear_diagonal_sw ?u ?v ?x ?y))


;; REMOVE PIECE

(<= (legal_remove ?player ?piece ?u ?v)
    (piece_owner ?piece ?player)
    (true (cell ?u ?v ?piece))
    (remove_piece ?player ?u ?v))

(<= (remove_piece redplayer ?u 1)
    (true (cell ?u 1 red)))

(<= (remove_piece blackplayer ?u 3)
    (true (cell ?u 3 black)))

;; ADD PIECE

(<= (legal_add ?player ?piece ?u ?v)
    (piece_owner ?piece ?player)
    (add_piece ?player ?u ?v))

(<= (add_piece redplayer ?u 3)
    (true (cell ?u 3 b)))

(<= (add_piece blackplayer ?u 1)
    (true (cell ?u 1 b)))

; NO-OPs for player not moving
(<= (legal redplayer noop)
    (true (control blackplayer)))
(<= (legal blackplayer noop)
    (true (control redplayer)))

; NO-OPs when no moves available
(<= (legal ?player noop)
    (role ?player)
    (true (control ?player))
    (not(has_legal_move ?player)))

;*******************************************************************************
; AUXILIARY PREDICATES                                                         *
;*******************************************************************************

;;;  DIFFERENT CELLS
;;;  True iff ?x1 ?y1 is a different cell from ?x2 ?y2

(<= (different_cells ?x1 ?y1 ?x2 ?y2)
    (distinct ?x1 ?x2)
    (coordinate ?x1)
    (coordinate ?x2)
    (coordinate ?y1)
    (coordinate ?y2))

(<= (different_cells ?x1 ?y1 ?x2 ?y2)
    (distinct ?y1 ?y2)
    (coordinate ?x1)
    (coordinate ?x2)
    (coordinate ?y1)
    (coordinate ?y2))

(<= (stuck ?player)
    (role ?player)
    (not (has_legal_move ?player)))

(<= (has_legal_move ?player)
    (legal_move ?player ?piece ?u ?v ?x ?y))
(<= (has_legal_move ?player)
    (legal_add ?player ?piece ?u ?v))
(<= (has_legal_move ?player)
    (legal_remove ?player ?piece ?u ?v))

(<= (occupied_by_opponent ?x ?y ?player)
    (true (cell ?x ?y ?piece))
    (opponent ?player ?opponent)
    (piece_owner ?piece ?opponent))

(<= (clear_diagonal_ne ?u ?v ?x ?y)
    (north_of ?y ?v)
    (east_of ?x ?u))

(<= (clear_diagonal_se ?u ?v ?x ?y)
    (south_of ?y ?v)
    (east_of ?x ?u))

(<= (clear_diagonal_nw ?u ?v ?x ?y)
    (north_of ?y ?v)
    (west_of ?x ?u))

(<= (clear_diagonal_sw ?u ?v ?x ?y)
    (south_of ?y ?v)
    (west_of ?x ?u))

; End auxiliary axioms 

;*******************************************************************************
;* GOALS AND TERMINAL STATES                                                   *
;* Player gets 100 for checkmating the opponent,                               *
;* 50 for stalemating and 0 for being checkmated.                              *
;*******************************************************************************
(<= (scorelimit_reached ?player) ; TODO - make it configurable!
    (true (score ?player 1)))


(<= (goal redplayer 100)
    (scorelimit_reached redplayer))

(<= (goal redplayer 0)
    (scorelimit_reached blackplayer))

(<= (goal blackplayer 100)
    (scorelimit_reached blackplayer))

(<= (goal blackplayer 0)
    (scorelimit_reached redplayer))

; Both players stuck
(<= (goal redplayer 100)
    (true (control redplayer))
    (stuck redplayer)
    (stuck blackplayer))

(<= (goal redplayer 0)
    (true (control blackplayer))
    (stuck redplayer)
    (stuck blackplayer))

(<= (goal blackplayer 100)
    (true (control blackplayer))
    (stuck redplayer)
    (stuck blackplayer))

(<= (goal blackplayer 0)
    (true (control redplayer))
    (stuck redplayer)
    (stuck blackplayer))

(<= terminal
    (scorelimit_reached ?player))

(<= terminal
    (stuck redplayer)
    (stuck blackplayer))

; End goals and terminals
;*******************************************************************************
;* GROUND FACTS                                                                *
;*******************************************************************************

; PLAYER OPPONENTS
(opponent redplayer blackplayer)
(opponent blackplayer redplayer)

; PIECE OWNERSHIP
(piece_owner red redplayer)
(piece_owner black blackplayer)

; BOARD TOPOLOGY
(north_of 1 2)
(north_of 2 3)

(south_of 3 2)
(south_of 2 1)

(west_of 3 2)
(west_of 2 1)

(east_of 1 2)
(east_of 2 3)

; BOARD COORDINATES

(coordinate 1)
(coordinate 2)
(coordinate 3)

(succ 0 1)
(succ 1 2)
(succ 2 3)
(succ 3 4)
